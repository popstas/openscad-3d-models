// =============================================
// 3D: funnel — воронка из 3 модулей
// Version: 1.0
// =============================================

description = "Parametric funnel: base ring, conical body, neck"; // one-line short description
version_str = "1.0";

// -------------------------------------------------
// Комментарии / Состав фрагментов
// -------------------------------------------------
// Фрагменты (все размеры задаются ниже параметрами):
// - p1_base()   — нижнее основание (цилиндр‑обод) высотой P1_H и диаметром P1_D
// - p2_frustum()— конический участок (усечённый конус) высотой P2_H
// - p3_neck()   — горлышко (цилиндр) высотой P3_H и диаметром P3_D
// Главная деталь base() = union(p1_base, p2_frustum, p3_neck)

// -------------------------------------------------
// Параметры модели (внешние габариты) и настройки
// -------------------------------------------------
// Геометрия
P1_D = 31;     // нижний внешний диаметр основания (мм)
P1_H = 0;      // высота основания (мм)
P2_H = 12;     // высота усечённого конуса (мм)
P3_D = 11.2;     // внешний диаметр горлышка (мм)
P3_H = 4;     // высота горлышка (мм)

wall_th = 1.0; // толщина стенок воронки (мм)

// Фаски/скругления (минимальные по умолчанию)
edge_ch_base = 0;   // фаска по верхнему краю основания (мм)
edge_ch_neck = 0;   // фаска по верхнему краю горлышка (мм)

// Опциональное скругление краёв всей детали через Minkowski
// Примечание: если mink_r > 0, внешние габариты увеличатся примерно на 2*mink_r
mink_r = 0;    // радиус скругления по краям (мм). 0 — без скругления

// Вывод фрагментов
print_base = true;     // печатать главную деталь base (все 3 фрагмента)
print_p1 = false;      // печатать отдельно фрагмент p1_base
print_p2 = false;      // печатать отдельно фрагмент p2_frustum
print_p3 = false;      // печатать отдельно фрагмент p3_neck

// -------------------------------------------------
// Подключение общих модулей
// -------------------------------------------------
use <../modules.scad>;

// -------------------------------------------------
// Настройка точности
// -------------------------------------------------
$fn = 0;        // фиксированную сегментацию отключаем
$fa = 6;        // 5–8° обычно достаточно
$fs = 0.35;     // ≈ диаметр сопла (0.3–0.5 для сопла 0.4)
pin_fs = 0.25;  // чуть тоньше для штырей и отверстий

// -------------------------------------------------
// Вычисляемые переменные и вспомогательные
// -------------------------------------------------
total_h = P1_H + P2_H + P3_H;  // общая высота воронки (без учёта mink_r)

// Внутренние диаметры (равномерная толщина стенок по диаметрам)
P1_D_in = max(P1_D - 2*wall_th, 0.5);
P3_D_in = max(P3_D - 2*wall_th, 0.5);

// Конус: внутренние диаметры линейно изменяются от P1_D_in (снизу) до P3_D_in (сверху)
// Никаких дополнительных отступов не требуется: слой материалов = wall_th по радиусу

// Вывод позиционируем в положительные X,Y для корректной обрезки test_fragment
// Для этого строим в центре, затем переносим на [P1_D/2, P1_D/2, 0]

// -------------------------------------------------
// Фрагменты детали
// -------------------------------------------------
module p1_base(){
  // Основание — кольцо
  translate([P1_D/2, P1_D/2, 0])
    difference(){
      cylinder(h=P1_H, d=P1_D);
      translate([0,0,-eps()]) cylinder(h=P1_H + 2*eps(), d=P1_D_in, $fs=pin_fs, $fa=6);
    }
  // Верхняя фаска основания (опционально)
  if (edge_ch_base > 0){
    translate([P1_D/2, P1_D/2, P1_H - edge_ch_base])
      chamfer_ring(d_outer=P1_D, d_inner=P1_D_in, h=edge_ch_base, chamfer=edge_ch_base);
  }
}

module p2_frustum(){
  // Участок усечённого конуса
  translate([P1_D/2, P1_D/2, P1_H])
    difference(){
      cylinder(h=P2_H, d1=P1_D, d2=P3_D);
      translate([0,0,-eps()])
        cylinder(h=P2_H + 2*eps(), d1=P1_D_in, d2=P3_D_in, $fs=pin_fs, $fa=6);
    }
}

module p3_neck(){
  // Горлышко — цилиндрическая труба
  translate([P1_D/2, P1_D/2, P1_H + P2_H])
    difference(){
      cylinder(h=P3_H, d=P3_D);
      translate([0,0,-eps()]) cylinder(h=P3_H + 2*eps(), d=P3_D_in, $fs=pin_fs, $fa=6);
    }
  if (edge_ch_neck > 0){
    translate([P1_D/2, P1_D/2, P1_H + P2_H + P3_H - edge_ch_neck])
      chamfer_ring(d_outer=P3_D, d_inner=P3_D_in, h=edge_ch_neck, chamfer=edge_ch_neck);
  }
}

// Главная деталь
module base(){
  union(){
    p1_base();
    p2_frustum();
    p3_neck();
  }
}

// Обёртка для Minkowski скругления (без сохранения габаритов)
module base_with_rounding(){
  if (mink_r > 0){
    minkowski(){
      base();
      sphere(r=mink_r, $fs=pin_fs, $fa=6);
    }
  } else base();
}

// Вывод всех фрагментов
module all_details(){
  if (print_base) base_with_rounding();
  if (print_p1) translate([P1_D + 10, 0, 0]) p1_base();
  if (print_p2) translate([P1_D + 10, P1_D + 10, 0]) p2_frustum();
  if (print_p3) translate([0, P1_D + 10, 0]) p3_neck();
}

// Финальная ориентация/обрезка для тест‑фрагментов
module orient(){ children(); }

// -------------------------------------------------
// ВЫВОД МОДЕЛИ
// -------------------------------------------------
module render(){
  // clip_for_fragments() берёт test_fragment/frag_* из моделей/modules.scad
  clip_for_fragments(){ orient(){ all_details(); } }
}

render();
